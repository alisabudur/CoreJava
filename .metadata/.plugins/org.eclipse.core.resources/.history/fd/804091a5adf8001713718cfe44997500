open ExpDeclaration;;
open ClassDeclaration;;
open MethodDeclaration;;
open TypeDeclaration;;
open ProgramDeclaration;;
open SubtypingUtils;;
open FieldDeclaration;;

let rec getVarType (varName: string) (te: (string*string) list) = 
	match te with
	| [] -> raise (Failure "Not Found")
	| h::t -> if first(h) = varName then (last(h)) else (getVarType varName t);;

let rec getTypeOfConstExp (e: constExp) = 
	match e with 
	| ConstInt(p) -> String.concat "" [string_of_int(p)]
	| ConstFloat(p) -> String.concat "" [string_of_float(p)]
	| ConstBool(p) -> String.concat "" [string_of_bool(p)]
	| ConstString(p) -> p
	| ConstVoid -> "void"
	| Null -> "null";;

let getTypeOfExp(e: exp) (te: (string*string) list) (p: cJProgram) = 
	match e with 
	| ArithIntExp(_, _, _) -> toStringCJType(CJPrimType(CJInt))
	| ArithFloatExp(_, _, _) -> toStringCJType(CJPrimType(CJFloat))
	(*| ConstExp(e) -> *)
	| VariableExp(name) -> getVarType name te
	| FieldValueExp(varName, fieldName) -> toStringCJType(getFieldType (getFieldWithName varName (getFieldList (getClassWithName (getVarType varName te) p))))
	| NotExp(_) -> toStringCJType(CJPrimType(CJBool))
	| GreaterExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| LessExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| EqualExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| NotEqualExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| AndExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| OrExp(_, _) -> toStringCJType(CJPrimType(CJBool))
	| _ -> "";;

let getTypeOfExp2 (e: exp2) (te: (string*string) list) (p: cJProgram) =
	match e with
	| NewExp(name, _) -> name
	| MethodCall(varName, name, varList) -> toStringCJType(getMethodReturnType (getMethodWithName name (getMethodList (getClassWithName (getVarType name te) p))));;







